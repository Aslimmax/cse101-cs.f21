// Filename: nqueens.cpp
//
// Usage: (the executable is generated by a Makefile)
//        ./nqueens <INPUT FILE> <OUTPUT FILE>
//
// The first number of the input file determines the size of the board (n x n), and every subsequent pair
// of numbers represents a queen on the board (col, row)
//
// Andrew Lim, Oct 2021

#include <iostream>
#include <stack>
#include <stdexcept>
#include <fstream>
#include <array>
#include <vector>
#include <algorithm>
#include <sstream>
using namespace std;

// Class used to store information about a Queen on a chessboard
class Queen {
	public:
		int col;
		int row;
        vector<vector<int>> chessboard;
        bool tempVar = false;
    
//     Queen(int col, int row) : col(col), row(row) {}
};

void printChessboard(vector<vector<int>> chessboard) {
    // Print out chessboard
	cout << "Chessboard: " << endl;
	int cols = chessboard.size();
	for (int i = cols - 1; i > 0; i--) {
		int rows = chessboard[0].size();
        if (i != cols) {
            if (i >= 10) {
                cout << "Row " << i << ":";
            } 
            else {
                cout << "Row  " << i << ":";
            }                    
        }
        for (int j = 1; j < rows; j++) {
//         cout << "{" << i << ", " << j << "}" << endl;
            if (chessboard[i][j] < 0) {
                cout << " " << chessboard [i][j] << "";
            } else {
                cout << "  " << chessboard[i][j];
                }
        }
	cout << "\n";
	}
}

bool getSolutionsStk(vector<vector<int>> &board, vector<class Queen> &nqueens, int boardDim, int rowCounter) {
    vector<class Queen> finalQueens = nqueens; // initialize output vector with queens already placed down
    stack<class Queen> recurStack; // initialize stack to hold valid queens
    
    Queen stacktop; // initialize reference to the top most queen in the stack
    vector<vector<int>> oldBoard = board; // keep a reference to the old board
    
    int row = rowCounter;
//     bool solutions = true; // check if a queen was placed in the row of the current iteration
    
    bool isSafe = true;
            
    while (row != boardDim) { // begin parsing rows to place a queen
        printChessboard(board);
        
        cout << "Stack Size: " << recurStack.size() << endl;
        cout << "Currently on row #" << row << endl;
        
//         if (recurStack.empty() && !solutions) { // if the stack is empty and the solutions flag is false
//             break;
//         }
        int i;
        if (!isSafe) {
            stacktop = recurStack.top();
            i = stacktop.col;
        } else {
            i = 1;
        }

        for (; i < boardDim; i++) { // loop through the columns in the given row
            isSafe = true;

            if (board[row][i] <= -1) { // can't place on an attack spot
                isSafe = false;
                continue;
            }
            else if (board[row][i] == 0) { // found an open spot to place a queen
                Queen tempQueen; // initialize queen to push to stack
                tempQueen.row = row;
                tempQueen.col = i; 
                tempQueen.chessboard = board;
                tempQueen.tempVar = false;
                
                recurStack.push(tempQueen); // push back queen to stack                 

                cout << "Snapshot of Stack" << endl;
                printChessboard(tempQueen.chessboard);
                cout << "Top Element on Stack: {" << row << ", " << i << "}" << endl;
                
                board[row][i] = 1; // place the queen on the board

                int colCord = i; // set the column cords
                int rowCord = row; // set the row cords

                // Populate queen's row/col attack paths
                // Don't overwrite placement of placed queen along row
                for (int j = 1; j < boardDim; j++) { 
                    if (j != rowCord) {
                        board[j][colCord] += -1;
                    }
                    // Don't overwrite placement of placed queen along col
                    if (j != colCord) {
                        board[rowCord][j] += -1;
                    }

                    // Populate queen diagonal attack paths
                    if (rowCord + j < boardDim && colCord + j < boardDim) {
                        board[rowCord + j][colCord + j] += -1; // upper right diagonal
                    }
                    if (rowCord - j > 0 && colCord - j > 0) {
                        board[rowCord - j][colCord - j] += -1; // lower left diagonal
                    }
                    if (rowCord - j > 0 && colCord + j < boardDim) {
                        board[rowCord - j][colCord + j] += -1;; // lower right diagonal
                    }
                    if (rowCord + j < boardDim && colCord - j > 0) {
                        board[rowCord + j e][colCord - j] += -1;; // upper left diagonal
                    }
                }
                cout << "Board after placing new queen" << endl;
                printChessboard(board);
                isSafe = true;
            }
            else if (board[row][i] == 1) { // there is already a queen in the row
                isSafe = true;
                break;
            }
            
            if (isSafe) {
//                 solutions = true;
                row++;
                break; // move onto the next row and continue to parse
            } 
        }
        
        if (!isSafe) { // backtrack, can't place a queen down in the row
            board = stacktop.chessboard;
            stacktop = recurStack.top();
            recurStack.pop();
            stacktop.col++;
//             recurStack.push(stacktop);
//             if (i == boardDim) {
//                 recurStack.pop();
//             } 
//             else {
//                 stacktop = recurStack.top();
//                 recurStack.pop();
//                 stacktop.col++;
//                 recurStack.push(stacktop);
//             }
            row--;                
        }
        
        if (recurStack.empty()) {
            break;
        }
                   
        
        // Have reached the end of the board and wasn't able to place down a new queen, need to backtrack
//         if (i == boardDim) {            
//             stacktop = recurStack.top();
                        
//             cout << "Queen to Pop: {" << stacktop.row << ", " << stacktop.col << "}" << endl;            
// //             if (stacktop.tempVar) {
// //                 recurStack.pop(); // pop dummy Queen
// //                 rowCounter--;
// //             }

//             stacktop = recurStack.top();
//             if (stacktop.col == (boardDim - 1) && !stacktop.tempVar) {
//                 recurStack.pop();
//                 rowCounter--;
//             }
//             board = stacktop.chessboard;
//             cout << "Chessboard of new iteration" << endl;
//             printChessboard(board);
            
//             solutions = false;
//         } 
    }
    
    return false;
}

bool getSolutions(vector<vector<int>> &board, vector<vector<int>> oldBoard, vector<class Queen> &nqueens, 
                  vector<class Queen> oldQueens, int boardDim, int row) {
    // valid base case: have processed through the entire board 
    // and was able to place a queen in every column without collision
    oldBoard = board; // make a copy of the previous board
    oldQueens = nqueens; // make a copy of the previous "list" of nQueens
    
    if (row == boardDim) {
        return true;
    }
    
    bool isSafe = true; // initialize safe spot to true
    
    // loop through the columns in the given row
    for (int i = 1; i < boardDim; i++) {
        isSafe = true;
        
        if (board[row][i] <= -1) { // can't place on an attack spot
            isSafe = false;
            continue;
        }
        else if (board[row][i] == 0) { // found an open spot to place a queen
            board[row][i] = 1; // place the queen down
            Queen tempQueen; // initialize queen object to store cords
            tempQueen.row = row;
            tempQueen.col = i;
            nqueens.push_back(tempQueen); // push back queen to nqueens "list"
            
            int colCord = i; // set the column cords
            int rowCord = row; // set the row cords
            
            // Populate queen's row/col attack paths
            // Don't overwrite placement of placed queen along row
            for (int j = 1; j < boardDim; j++) { 
				if (j != rowCord) {
					board[j][colCord] += -1;
				}
				// Don't overwrite placement of placed queen along col
				if (j != colCord) {
					board[rowCord][j] += -1;
				}
				
				// Populate queen diagonal attack paths
				if (rowCord + j < boardDim && colCord + j < boardDim) {
					board[rowCord + j][colCord + j] += -1; // upper right diagonal
				}
				if (rowCord - j > 0 && colCord - j > 0) {
					board[rowCord - j][colCord - j] += -1; // lower left diagonal
				}
				if (rowCord - j > 0 && colCord + j < boardDim) {
					board[rowCord - j][colCord + j] += -1;; // lower right diagonal
				}
				if (rowCord + j < boardDim && colCord - j > 0) {
					board[rowCord + j][colCord - j] += -1;; // upper left diagonal
				}
            }
        } 
        else if (board[row][i] == 1) { // there is already a queen in the row
            isSafe = true;
        }
        
        if (isSafe) {
            if (getSolutions(board, oldBoard, nqueens, oldQueens, boardDim, row + 1)) {
                return true;
            } else {
                board = oldBoard; // revert board to previous board
                nqueens = oldQueens; // revert queens to previous "list" of queens
            }
        }         
    }
    
    return false;
}

int main(int argc, char** argv) {
	if (argc < 3) { // must provide two arguments as input
		throw std::invalid_argument("Usage: ./nqueens <INPUT FILE> <OUTPUT FILE>"); // throw error
	}
	
	/*
	 * Input/output processing code
	 */
	
	ifstream input; // initialize stream for input file
	ofstream output;  // initialize stream for output file
	
	input.open(argv[1]); // open input file
	output.open(argv[2]); // open output file
	
	string nqueensProblem = ""; // initialize string to store input lines
	
	while (getline(input, nqueensProblem)) { // loop through input file
		stringstream ss; // initialize stringstream object for parsing
		ss << nqueensProblem; // turn input line into stringstream
			
		vector<class Queen> nqueens; // initialize vector to store num of queens in input
		vector<vector<int>> chessboard; // initialize chessboard 
		Queen tempQueen; // temporary queen object
		
		string tempStr= ""; // temp string var to get each num
		int tempInt = 0; // temp int var to store string conversion
		int counter = 0; // keep track of when a valid queen has been inputted (col, row)
		
		while (!ss.eof()) { // loop through input line
			ss >> tempStr; // get nums from input one by one
			stringstream(tempStr) >> tempInt; // convert string to int
			
			// first number of each input is the board dimensions
			if (counter == 0) { 
				int dimensions = tempInt + 1; // set the dimensions to have a 1 offset (going to ignore the 0th indexed)
				chessboard.resize(dimensions); // initialize cols in the board
				for (int i = 0; i < dimensions; i++) { // loop through each column
					chessboard[i].resize(dimensions, 0); // populate the chessboard rows with 0s
				}
				counter++; // increment counter to begin processing queens
			}			
			// subsequent numbers after the board will be a queen
			else if (counter > 0) { 
				if (counter == 1) { // first num of a queen is the col
					tempQueen.col = tempInt; // set col to tempInt
					counter++; // increment counter to parse the row value
				} else if (counter == 2) { // second num of a queen in the row
					tempQueen.row = tempInt; // set row to tempInt
					nqueens.push_back(tempQueen); // push queen into n queens 2d vector
					counter = 1; // reset counter to 1 to process additional queens
				}
			}
		}
		
		// At this point, the chessboard has been initialized and we have our queens in nqueens
		// Verify that the chess board is not of size 3 (2x2 + 1 offset) or 4 (3x3 + 1 offset)
		int chessboardDim = chessboard.size();
		if (chessboardDim == 3 || chessboardDim == 4) {
			output << "No solution" << "\n";
            continue;
		}
		
		// Verify that inputs are valid (no 2 queens have the same row/col and no collisions along diagonal)
		int numQueens = nqueens.size(); // get the num of queens in nqueens
		bool uniqueVals = true;
		if (numQueens > 1) { // don't need to perform santiy check if there is only one queen or no queens
			vector<int> colVals, rowVals; // iniitalize vectors to store the col and row vals in every queen
			for (int i = 0; i < numQueens; i++) {
				colVals.push_back(nqueens[i].col); // push the col val of one queen
				rowVals.push_back(nqueens[i].row); // push the row val of one queen
			}
			
			// Check that queens are on their own unique column
			sort(colVals.begin(), colVals.end()); // sort vector vals
			auto vecIter = unique(colVals.begin(), colVals.end()); 
			uniqueVals = (vecIter == colVals.end() ? true : false);
			if (!uniqueVals) {
                output << "No solution\n";
                break;
// 				cout << "Cols No solution" << endl;
				// Continue to next line in input
			} else {
				cout << "Cols pass" << endl;
			}
			
			// Check that queens are on their own unique row
			sort(rowVals.begin(), rowVals.end()); // sort vector vals
			vecIter = unique(rowVals.begin(), rowVals.end());
			uniqueVals = (vecIter == rowVals.end() ? true : false);
			if (!uniqueVals) {
                output << "No solution\n";
                break;
// 				cout << "Row No Solution" << endl;
				// Continue to next line in input
			} else {
				cout << "Rows pass" << endl;
			}
		} 
		
		// Start placing input Queens on board and update the chess board.
		// If there is a single collision from the inputs, output "No solution".
		// Mind the vector index (input {col, row} ==> chessboard[row][col])
		// 0: safe spot
		// 1: position of queen
		// < 0: path of a queen's attack
		bool invalidBoard = false;
		for (int i = 0; i < numQueens; i++) {
			int rowCord = nqueens[i].row; // store row coordinate of queen
			int colCord = nqueens[i].col; // store col coordinate of queen
			// Validate that queen is not placed on attack path of another queen and not on another queen
			if (chessboard[rowCord][colCord] == -1 || chessboard[rowCord][colCord] == 1) {
                output << "No solution\n";
// 				cout << "Invalid Inputs: No solution" << endl;
				invalidBoard = true;
				break;
			}
			chessboard[rowCord][colCord] = 1; // place queen on board
			// update board with queen's attack path
			for (int j = 1; j < chessboardDim; j++) {
				// Populate queen's row/col attack paths

				// Don't overwrite placement of placed queen along row
				if (j != rowCord) {
					chessboard[j][colCord] += -1;
				}
				// Don't overwrite placement of placed queen along col
				if (j != colCord) {
					chessboard[rowCord][j] += -1;
				}
				
				// Populate queen diagonal attack paths
				if (rowCord + j < chessboardDim && colCord + j < chessboardDim) {
					chessboard[rowCord + j][colCord + j] += -1; // upper right diagonal
				}
				if (rowCord - j > 0 && colCord - j > 0) {
					chessboard[rowCord - j][colCord - j] += -1; // lower left diagonal
				}
				if (rowCord - j > 0 && colCord + j < chessboardDim) {
					chessboard[rowCord - j][colCord + j] += -1;; // lower right diagonal
				}
				if (rowCord + j < chessboardDim && colCord - j > 0) {
					chessboard[rowCord + j][colCord - j] += -1;; // upper left diagonal
				}
			}
		}
        
        // Move onto next line if input is invalid
        if (invalidBoard) {
            break;
        }
        
        cout << "Initial Board: " << endl;
        printChessboard(chessboard);
        // 		if (!getSolutions(chessboard, nqueens, chessboardDim, 1)) {

        // At this point, input queens have been placed onto the board and are valid
        // Can begin to recursively place queens
        vector<class Queen> oldQueens = nqueens;
//         if (!(getSolutions(chessboard, chessboard, nqueens, oldQueens, chessboardDim, 1))) {
        if (!getSolutionsStk(chessboard, nqueens, chessboardDim, 1)) {

            output << "No solution\n";
        }
            
        // Process nqueens into output
        numQueens = nqueens.size();
        for (int i = 0; i < numQueens; i++) {
            output << nqueens[i].col << " " << nqueens[i].row << " ";
        }

		// DEBUG: Print out col/rows of the queens
// 		int numQueens = nqueens.size();
// 		for (int i = 0; i < numQueens; i++) {
// 			cout << "Queen #" << i << ": {col: " << nqueens[i].col 
// 				<< ", row: " << nqueens[i].row << "}" << endl;
// 		}
		
        printChessboard(chessboard);
	}
  
    return 0;
}