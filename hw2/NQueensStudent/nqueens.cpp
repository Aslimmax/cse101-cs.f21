// Filename: nqueens.cpp
//
// Usage: (the executable is generated by a Makefile)
//        ./nqueens <INPUT FILE> <OUTPUT FILE>
//
// The first number of the input file determines the size of the board (n x n), and every subsequent pair
// of numbers represents a queen on the board (col, row)
//
// Andrew Lim, Oct 2021

#include <iostream>
#include <stack>
#include <stdexcept>
#include <fstream>
#include <array>
#include <vector>
#include <algorithm>
#include <sstream>
using namespace std;

// Class used to store information about a Queen on a chessboard
class Queen {
	public:
		int col;
		int row;
        vector<vector<int>> chessboard;
        bool tempVar = false;
    
//     Queen(int col, int row) : col(col), row(row) {}
};

void printChessboard(vector<vector<int>> chessboard) {
    // Print out chessboard
	cout << "Chessboard: " << endl;
	int cols = chessboard.size();
	for (int i = cols - 1; i > 0; i--) {
		int rows = chessboard[0].size();
        if (i != cols) {
            if (i >= 10) {
                cout << "Row " << i << ":";
            } 
            else {
                cout << "Row  " << i << ":";
            }                    
        }
        for (int j = 1; j < rows; j++) {
//         cout << "{" << i << ", " << j << "}" << endl;
            if (chessboard[i][j] < 0) {
                cout << " " << chessboard [i][j] << "";
            } else {
                cout << "  " << chessboard[i][j];
                }
        }
	cout << "\n";
	}
}

bool getSolutionsStk(vector<vector<int>> &board, vector<class Queen> &nqueens, int boardDim, int rowCounter) {
    vector<class Queen> finalQueens = nqueens; // initialize output vector with queens already placed down
    stack<class Queen> recurStack; // initialize stack to hold valid queens
    // create an initial Queen to start the stack-based recursion and initialize a 
    // variable reference to the top most queen in the stack
    Queen init, stacktop; 
    init.row = rowCounter; // start from row 1
    vector<vector<int>> oldBoard = board; // keep a reference to the old board
    recurStack.push(init);
    
    while (!recurStack.empty()) {
        oldBoard = board; // make a copy of the previous board
        stacktop = recurStack.top(); // get the top of the stack
        recurStack.pop(); // remove the top of the stack
        
        printChessboard(stacktop.chessboard);
        
        bool queenInEveryRow = false;
        int queenCounter = 0;
        int rowCounter = 1;
        
        // validate that there is a queen in every row
        while(rowCounter != boardDim) {
            // loop through all columns in the given row
            for (int i = 1; i < boardDim; i++) {
                if(board[rowCounter][i] == 1) { // there is already a queen in the row
                    queenCounter++;
                    break;
                }
            }
            
            rowCounter++;
        }
        cout << queenCounter << endl;
        cout << boardDim - 1 << endl;
        cout << stacktop.row << endl;
        if (nqueens == (boardDim - 1)) {
            return true; // NEED TO CHANGE RETURN TYPE
            break;
        }
        else if (stacktop.row == (boardDim - 1))'
            ' { // backtrack
            cout << "BACKTRACK" << endl;
            Queen tempQueen;
// n queen
            tempQueen.chessboard = stacktop.chessboard; // restore previous board
            tempQueen.row = stacktop.row - 1;
            tempQueen.row = stacktop.col + 1;
            recurStack.push(tempQueen);
            continue;
        }
        
        bool isSafe = true; // initialize safe spot
        
        int row = stacktop.row;
        int col = stacktop.col;
        
        // Loop through the columns in the given row
        for (int i = col; i < boardDim; i++) {
            isSafe = true;
            if (board[row][i] <= -1) { // can't place on an attack spot
                isSafe = false;
                continue;
            }
            else if (board[row][i] == 1) { // there is already a queen in the row
                isSafe = true;
            }
            else if (board[row][i] == 0) { // found an open spot to place a queen
                Queen tempQueen; // initialize queen object to store cords
                tempQueen.row = row;
                tempQueen.col = i;
                tempQueen.chessboard = oldBoard;
//                 printChessboard(tempQueen.chessboard);
                nqueens.push_back(tempQueen); // push back queen to nqueens "list"
                
                board[row][i] = 1; // place the queen down

                int colCord = i; // set the column cords
                int rowCord = row; // set the row cords

                // Populate queen's row/col attack paths
                // Don't overwrite placement of placed queen along row
                for (int j = 1; j < boardDim; j++) { 
                    if (j != rowCord) {
                        board[j][colCord] += -1;
                    }
                    // Don't overwrite placement of placed queen along col
                    if (j != colCord) {
                        board[rowCord][j] += -1;
                    }

                    // Populate queen diagonal attack paths
                    if (rowCord + j < boardDim && colCord + j < boardDim) {
                        board[rowCord + j][colCord + j] += -1; // upper right diagonal
                    }
                    if (rowCord - j > 0 && colCord - j > 0) {
                        board[rowCord - j][colCord - j] += -1; // lower left diagonal
                    }
                    if (rowCord - j > 0 && colCord + j < boardDim) {
                        board[rowCord - j][colCord + j] += -1;; // lower right diagonal
                    }
                    if (rowCord + j < boardDim && colCord - j > 0) {
                        board[rowCord + j][colCord - j] += -1;; // upper left diagonal
                    }
                }
                
                isSafe = true;
            } 
            
            if (isSafe) {
                Queen tempQueen;
                tempQueen.row = stacktop.row + 1;
                tempQueen.col = col;
                tempQueen.chessboard = oldBoard;
                recurStack.push(tempQueen);
                break;
            }
        }
    }
    
//     while (!recurStack.empty()) {
//         stacktop = recurStack.top(); // get the top of the stack
//         recurStack.pop(); // remove the top of the stack
//         // exit condition: have completed parsing and placing all queens on the board
//         if (finalQueens.size() == (boardDim - 1)) {
//             return true; // NEED TO CHANGE RETURN TYPE
//             break;
//         }
        
//         int row = 1; // initialize row counter to loop through all rows
//         bool queenInRow = true; // whether or not the queen is in the row
        
//         // validate that there is no queen in the row
//         while(queenInRow) {
//             queenInRow = false;
//             // loop through the columns in the given row
//             for (int i = 1; i < boardDim; i++) {
//                 if (board[row][i] <= -1) { // can't place on an attack spot
//                     continue;
//                 }
//                 else if(board[row][i] == 1) { // there is already a queen in the row
//                     queenInRow = true;
//                     break;
//                 }
//             }
//             if (!queenInRow) {
//                 break;
//             }
            
//             row++;
//         }
        
//         // Found a row that has no queen, need to determine where to place it
//         // But if the row exceeds the boardDim, we need to backtrack
//         if (row >= boardDim) {
//             board = stacktop.chessboard; // restore the previous board revision
            
//         } else {
//             for (int i = 1; i < boardDim; i++) {
//                 if (board[row][i] == 0) {
//                     Queen tempQueen; // initialize queen to push to stack
//                     tempQueen.row = row;
//                     tempQueen.col = i; 
//                     tempQueen.chessboard = board;
//                     tempQueen.tempVar = false;

//                     recurStack.push(tempQueen); // push back queen to stack
//                     finalQueens.push_back(tempQueen);

//     //                 cout << "Snapshot of Stack" << endl;
//     //                 printChessboard(tempQueen.chessboard);
//     //                 cout << "Top Element on Stack: {" << row << ", " << i << "}" << endl;

//                     board[row][i] = 1; // place the queen on the board

//                     int colCord = i; // set the column cords
//                     int rowCord = row; // set the row cords

//                     // Populate queen's row/col attack paths
//                     // Don't overwrite placement of placed queen along row
//                     for (int j = 1; j < boardDim; j++) { 
//                         if (j != rowCord) {
//                             board[j][colCord] += -1;
//                         }
//                         // Don't overwrite placement of placed queen along col
//                         if (j != colCord) {
//                             board[rowCord][j] += -1;
//                         }

//                         // Populate queen diagonal attack paths
//                         if (rowCord + j < boardDim && colCord + j < boardDim) {
//                             board[rowCord + j][colCord + j] += -1; // upper right diagonal
//                         }
//                         if (rowCord - j > 0 && colCord - j > 0) {
//                             board[rowCord - j][colCord - j] += -1; // lower left diagonal
//                         }
//                         if (rowCord - j > 0 && colCord + j < boardDim) {
//                             board[rowCord - j][colCord + j] += -1;; // lower right diagonal
//                         }
//                         if (rowCord + j < boardDim && colCord - j > 0) {
//                             board[rowCord + j][colCord - j] += -1;; // upper left diagonal
//                         }
//                     }
//                 printChessboard(board);
//                 }
//             }
            
//         }

//     }
}

bool getSolutions(vector<vector<int>> &board, vector<vector<int>> oldBoard, vector<class Queen> &nqueens, 
                  vector<class Queen> oldQueens, int boardDim, int row) {
    // valid base case: have processed through the entire board 
    // and was able to place a queen in every column without collision
    oldBoard = board; // make a copy of the previous board
    oldQueens = nqueens; // make a copy of the previous "list" of nQueens
    
    printChessboard(board);
    
    if (row == boardDim) {
        return true;
    }
    
    bool isSafe = true; // initialize safe spot to true
    
    // loop through the columns in the given row
    for (int i = 1; i < boardDim; i++) {
        isSafe = true;
        
        if (board[row][i] <= -1) { // can't place on an attack spot
            isSafe = false;
            continue;
        }
        else if (board[row][i] == 0) { // found an open spot to place a queen
            board[row][i] = 1; // place the queen down
            Queen tempQueen; // initialize queen object to store cords
            tempQueen.row = row;
            tempQueen.col = i;
            nqueens.push_back(tempQueen); // push back queen to nqueens "list"
            
            int colCord = i; // set the column cords
            int rowCord = row; // set the row cords
            
            // Populate queen's row/col attack paths
            // Don't overwrite placement of placed queen along row
            for (int j = 1; j < boardDim; j++) { 
				if (j != rowCord) {
					board[j][colCord] += -1;
				}
				// Don't overwrite placement of placed queen along col
				if (j != colCord) {
					board[rowCord][j] += -1;
				}
				
				// Populate queen diagonal attack paths
				if (rowCord + j < boardDim && colCord + j < boardDim) {
					board[rowCord + j][colCord + j] += -1; // upper right diagonal
				}
				if (rowCord - j > 0 && colCord - j > 0) {
					board[rowCord - j][colCord - j] += -1; // lower left diagonal
				}
				if (rowCord - j > 0 && colCord + j < boardDim) {
					board[rowCord - j][colCord + j] += -1;; // lower right diagonal
				}
				if (rowCord + j < boardDim && colCord - j > 0) {
					board[rowCord + j][colCord - j] += -1;; // upper left diagonal
				}
            }
        } 
        else if (board[row][i] == 1) { // there is already a queen in the row
            isSafe = true;
        }
        
        if (isSafe) {
            if (getSolutions(board, oldBoard, nqueens, oldQueens, boardDim, row + 1)) {
                return true;
            } else {
                board = oldBoard; // revert board to previous board
                nqueens = oldQueens; // revert queens to previous "list" of queens
            }
        }         
    }
    
    return false;
}

int main(int argc, char** argv) {
	if (argc < 3) { // must provide two arguments as input
		throw std::invalid_argument("Usage: ./nqueens <INPUT FILE> <OUTPUT FILE>"); // throw error
	}
	
	/*
	 * Input/output processing code
	 */
	
	ifstream input; // initialize stream for input file
	ofstream output;  // initialize stream for output file
	
	input.open(argv[1]); // open input file
	output.open(argv[2]); // open output file
	
	string nqueensProblem = ""; // initialize string to store input lines
	
	while (getline(input, nqueensProblem)) { // loop through input file
		stringstream ss; // initialize stringstream object for parsing
		ss << nqueensProblem; // turn input line into stringstream
			
		vector<class Queen> nqueens; // initialize vector to store num of queens in input
		vector<vector<int>> chessboard; // initialize chessboard 
		Queen tempQueen; // temporary queen object
		
		string tempStr= ""; // temp string var to get each num
		int tempInt = 0; // temp int var to store string conversion
		int counter = 0; // keep track of when a valid queen has been inputted (col, row)
		
		while (!ss.eof()) { // loop through input line
			ss >> tempStr; // get nums from input one by one
			stringstream(tempStr) >> tempInt; // convert string to int
			
			// first number of each input is the board dimensions
			if (counter == 0) { 
				int dimensions = tempInt + 1; // set the dimensions to have a 1 offset (going to ignore the 0th indexed)
				chessboard.resize(dimensions); // initialize cols in the board
				for (int i = 0; i < dimensions; i++) { // loop through each column
					chessboard[i].resize(dimensions, 0); // populate the chessboard rows with 0s
				}
				counter++; // increment counter to begin processing queens
			}			
			// subsequent numbers after the board will be a queen
			else if (counter > 0) { 
				if (counter == 1) { // first num of a queen is the col
					tempQueen.col = tempInt; // set col to tempInt
					counter++; // increment counter to parse the row value
				} else if (counter == 2) { // second num of a queen in the row
					tempQueen.row = tempInt; // set row to tempInt
					nqueens.push_back(tempQueen); // push queen into n queens 2d vector
					counter = 1; // reset counter to 1 to process additional queens
				}
			}
		}
		
		// At this point, the chessboard has been initialized and we have our queens in nqueens
		// Verify that the chess board is not of size 3 (2x2 + 1 offset) or 4 (3x3 + 1 offset)
		int chessboardDim = chessboard.size();
		if (chessboardDim == 3 || chessboardDim == 4) {
			output << "No solution" << "\n";
            continue;
		}
		
		// Verify that inputs are valid (no 2 queens have the same row/col and no collisions along diagonal)
		int numQueens = nqueens.size(); // get the num of queens in nqueens
		bool uniqueVals = true;
		if (numQueens > 1) { // don't need to perform santiy check if there is only one queen or no queens
			vector<int> colVals, rowVals; // iniitalize vectors to store the col and row vals in every queen
			for (int i = 0; i < numQueens; i++) {
				colVals.push_back(nqueens[i].col); // push the col val of one queen
				rowVals.push_back(nqueens[i].row); // push the row val of one queen
			}
			
			// Check that queens are on their own unique column
			sort(colVals.begin(), colVals.end()); // sort vector vals
			auto vecIter = unique(colVals.begin(), colVals.end()); 
			uniqueVals = (vecIter == colVals.end() ? true : false);
			if (!uniqueVals) {
                output << "No solution\n";
                break;
// 				cout << "Cols No solution" << endl;
				// Continue to next line in input
			} else {
				cout << "Cols pass" << endl;
			}
			
			// Check that queens are on their own unique row
			sort(rowVals.begin(), rowVals.end()); // sort vector vals
			vecIter = unique(rowVals.begin(), rowVals.end());
			uniqueVals = (vecIter == rowVals.end() ? true : false);
			if (!uniqueVals) {
                output << "No solution\n";
                break;
// 				cout << "Row No Solution" << endl;
				// Continue to next line in input
			} else {
				cout << "Rows pass" << endl;
			}
		} 
		
		// Start placing input Queens on board and update the chess board.
		// If there is a single collision from the inputs, output "No solution".
		// Mind the vector index (input {col, row} ==> chessboard[row][col])
		// 0: safe spot
		// 1: position of queen
		// < 0: path of a queen's attack
		bool invalidBoard = false;
		for (int i = 0; i < numQueens; i++) {
			int rowCord = nqueens[i].row; // store row coordinate of queen
			int colCord = nqueens[i].col; // store col coordinate of queen
			// Validate that queen is not placed on attack path of another queen and not on another queen
			if (chessboard[rowCord][colCord] == -1 || chessboard[rowCord][colCord] == 1) {
                output << "No solution\n";
// 				cout << "Invalid Inputs: No solution" << endl;
				invalidBoard = true;
				break;
			}
			chessboard[rowCord][colCord] = 1; // place queen on board
			// update board with queen's attack path
			for (int j = 1; j < chessboardDim; j++) {
				// Populate queen's row/col attack paths

				// Don't overwrite placement of placed queen along row
				if (j != rowCord) {
					chessboard[j][colCord] += -1;
				}
				// Don't overwrite placement of placed queen along col
				if (j != colCord) {
					chessboard[rowCord][j] += -1;
				}
				
				// Populate queen diagonal attack paths
				if (rowCord + j < chessboardDim && colCord + j < chessboardDim) {
					chessboard[rowCord + j][colCord + j] += -1; // upper right diagonal
				}
				if (rowCord - j > 0 && colCord - j > 0) {
					chessboard[rowCord - j][colCord - j] += -1; // lower left diagonal
				}
				if (rowCord - j > 0 && colCord + j < chessboardDim) {
					chessboard[rowCord - j][colCord + j] += -1;; // lower right diagonal
				}
				if (rowCord + j < chessboardDim && colCord - j > 0) {
					chessboard[rowCord + j][colCord - j] += -1;; // upper left diagonal
				}
			}
		}
        
        // Move onto next line if input is invalid
        if (invalidBoard) {
            break;
        }
        
        cout << "Initial Board: " << endl;
        printChessboard(chessboard);
        // 		if (!getSolutions(chessboard, nqueens, chessboardDim, 1)) {

        // At this point, input queens have been placed onto the board and are valid
        // Can begin to recursively place queens
        vector<class Queen> oldQueens = nqueens;
//         if (!(getSolutions(chessboard, chessboard, nqueens, oldQueens, chessboardDim, 1))) {
        if (!getSolutionsStk(chessboard, nqueens, chessboardDim, 1)) {

            output << "No solution\n";
        }
            
        // Process nqueens into output
        numQueens = nqueens.size();
        for (int i = 0; i < numQueens; i++) {
            output << nqueens[i].col << " " << nqueens[i].row << " ";
        }

		// DEBUG: Print out col/rows of the queens
// 		int numQueens = nqueens.size();
// 		for (int i = 0; i < numQueens; i++) {
// 			cout << "Queen #" << i << ": {col: " << nqueens[i].col 
// 				<< ", row: " << nqueens[i].row << "}" << endl;
// 		}
		
        printChessboard(chessboard);
	}
  
    return 0;
}